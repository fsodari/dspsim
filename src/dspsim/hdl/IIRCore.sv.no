module IIRCore #(
    parameter DW = 24,
    parameter COEFW = 18,
    // parameter COEFQ = 16,
    parameter ORDER = 2,
    localparam N = (ORDER+1)*2
) (
    input  logic clk,
    input  logic rst,
    input  logic signed [DW-1:0] s_axis_tdata,
    input  logic s_axis_tvalid,
    output logic s_axis_tready,

    output logic signed [DW-1:0] m_axis_tdata,
    output logic m_axis_tvalid,
    input  logic m_axis_tready,

    input  logic signed [COEFW-1:0] coefs [N-1:0]
);

localparam MW = DW + COEFW;
localparam ACCUMW = MW + $clog2(N);

// Accumulator regs
logic accum_ce, sload;
logic sload_reg;

logic signed [COEFW-1:0] coef_reg;
logic signed [DW-1:0] data_reg;
logic signed [MW-1:0] mult;
logic signed [ACCUMW-1:0] adder_out, old_result;

// Adjusted coefficients.
logic signed [COEFW-1:0] coefs_adj [N-1:0];
logic [4:0] shift_amount;
// assign shift_amount = coefs[ORDER+1][7:0];
// assign shift_amount = COEFQ;

PriorityEncoder #(
    .N(COEFW),
    .LSB_HIGH_PRIORITY(0)
) shift_amt_decoder (
    .d(coefs[3]),
    .q(shift_amount),
    /* verilator lint_off PINCONNECTEMPTY */
    .valid_o(),
    .mask()
    /* verilator lint_on PINCONNECTEMPTY */
);

generate
for (genvar i = 0; i < N; i++) begin : adjusted_coefs
    if (i < ORDER+1) begin : numerator_coefs
        assign coefs_adj[i] =  coefs[i];
    end else if (i > ORDER+1) begin : denominator_coefs
        assign coefs_adj[i] = -coefs[i];
    end
end
endgenerate

logic [$clog2(N)-1:0] coef_index = 0;

logic signed [DW-1:0] data_state [N];

logic [DW-1:0] frac_mask;
assign frac_mask = (1 << shift_amount) - 1;

/*verilator lint_off UNUSED */
logic signed [ACCUMW-1:0] accum_shift;
/*verilator lint_on UNUSED */

assign accum_shift = adder_out >>> shift_amount;

logic [8:0] ce_pipe = 0;
assign accum_ce = |ce_pipe[8:0];
assign sload = ce_pipe[1];

logic signed [DW-1:0] skid_tdata;
logic skid_tvalid, skid_tready;
Skid #(.DW(DW)) skid_i (
    .clk,
    .rst,
    .s_axis_tdata,
    .s_axis_tvalid,
    .s_axis_tready,
    .m_axis_tdata(skid_tdata),
    .m_axis_tvalid(skid_tvalid),
    .m_axis_tready(skid_tready)
);

// Accept input data every NCOEF clock cycles. The data output will be pipelined.
always @(posedge clk) begin
    // Data takes a fixed amount of time to propagate. Track the data stage with a shift register.
    ce_pipe <= {ce_pipe[7:0], skid_tvalid & skid_tready};

    // Handle output logic.
    if (m_axis_tvalid && m_axis_tready) begin
        m_axis_tvalid <= 0;
    end

    // Data is valid NCOEF + 3 cycles after input. NCOEF coefs + 1 input reg + 1 mult reg + 1 accum reg
    if (ce_pipe[N + 2]) begin
        m_axis_tdata <= accum_shift[DW-1:0];
        m_axis_tvalid <= 1;

        // Shift the y regs.
        data_state[ORDER+1] <= adder_out[DW-1:0] & frac_mask; // Save the fraction
        data_state[ORDER+2] <= accum_shift[DW-1:0];

        for (int i = ORDER+3; i < N; i++) begin
            data_state[i] <= data_state[i-1];
        end
    end

    if (skid_tvalid && skid_tready) begin
        skid_tready <= 0;
        coef_index <= 0;

        // Shift incoming data into registers.
        data_state[0] <= skid_tdata;
        for (int i = 1; i < (ORDER+1); i++) begin
            data_state[i] <= data_state[i-1];
        end
    end

    // Processing data and coefficients.
    if (!skid_tready) begin
        coef_index <= coef_index + 1;

        // We can accept more incoming data once all of the inputs have been processed.
        if (coef_index == (N-2)) begin
            skid_tready <= 1;
        end
    end

    if (rst) begin
        skid_tready <= 1;
        m_axis_tvalid <= 0;
        coef_index <= 0;
        ce_pipe <= 0;

        for (int i = 0; i < N; i++) begin
            data_state[i] <= 0;
        end
    end
end

// Accumulator logic
always @(posedge clk) begin
    if (accum_ce) begin
        sload_reg <= sload;
        data_reg <= data_state[coef_index];
        coef_reg <= coefs_adj[coef_index];
        mult <= data_reg * coef_reg;
        adder_out <= old_result + {{(ACCUMW-MW){mult[MW-1]}}, mult}; // Sign extend.
    end
end
always_comb begin
    if (sload_reg) begin
        old_result = 0;
    end else begin
        old_result = adder_out;
    end
end

endmodule
